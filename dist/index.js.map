{"version":3,"sources":["../src/index.js"],"names":["UNITS","YEAR","MONTH","DAY","HOUR","MINUTE","SECOND","YEAR_UNIT","MONTH_UNIT","DAY_UNIT","HOUR_UNIT","MINUTE_UNIT","SECOND_UNIT","IS_NEGATIVE_UNIT","periodUnits","timeUnits","allowedUnits","emptyPeriod","emptyTime","isValidXsdDuration","test","str","isNonEmptyString","input","length","isNegative","stripFirstChar","slice","unitToSeconds","unit","amount","toUpperCase","parseUnit","amt","getNumber","parseFloat","isNaN","parsePeriod","exec","period","year","month","day","parsePeriodToObject","years","months","days","parseTime","time","hour","minute","second","parseTimeToObject","hours","minutes","seconds","parse","neg","duration","splitDuration","split","output","convertToObject","Object","assign","out","toObject","TypeError"],"mappings":"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","file":"index.js","sourcesContent":["const UNITS = {\n  YEAR: 31536000,\n  MONTH: 2628000,\n  DAY: 86400,\n  HOUR: 3600,\n  MINUTE: 60,\n  SECOND: 1\n}\n\nexport const YEAR_UNIT = 'years'\nexport const MONTH_UNIT = 'months'\nexport const DAY_UNIT = 'days'\nexport const HOUR_UNIT = 'hours'\nexport const MINUTE_UNIT = 'minutes'\nexport const SECOND_UNIT = 'seconds'\nexport const IS_NEGATIVE_UNIT = 'isNegative'\n\nexport const periodUnits = [YEAR_UNIT, MONTH_UNIT, DAY_UNIT]\n\nexport const timeUnits = [HOUR_UNIT, MINUTE_UNIT, SECOND_UNIT]\n\nexport const allowedUnits = [IS_NEGATIVE_UNIT, ...periodUnits, ...timeUnits]\n\nexport const emptyPeriod = {\n  [YEAR_UNIT]: 0,\n  [MONTH_UNIT]: 0,\n  [DAY_UNIT]: 0\n}\n\nexport const emptyTime = {\n  [HOUR_UNIT]: 0,\n  [MINUTE_UNIT]: 0,\n  [SECOND_UNIT]: 0\n}\n\n// Regex taken from https://www.w3.org/TR/xmlschema11-2/#duration-lexical-space\nexport const isValidXsdDuration = str =>\n  /^-?P((([0-9]+Y([0-9]+M)?([0-9]+D)?|([0-9]+M)([0-9]+D)?|([0-9]+D))(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S)))?)|(T(([0-9]+H)([0-9]+M)?([0-9]+(\\.[0-9]+)?S)?|([0-9]+M)([0-9]+(\\.[0-9]+)?S)?|([0-9]+(\\.[0-9]+)?S))))$/.test(\n    str\n  )\nconst isNonEmptyString = input => typeof input === 'string' && input.length > 0\nconst isNegative = str => str[0] === '-'\nconst stripFirstChar = str => str.slice(1)\nconst unitToSeconds = (unit, amount) => UNITS[unit.toUpperCase()] * amount\n\nconst parseUnit = (unit, amount) => {\n  const amt = getNumber(amount)\n  return unitToSeconds(unit, amt)\n}\n\nexport const getNumber = amount => {\n  const amt = parseFloat(amount)\n  if (isNaN(amt)) return 0\n  return amt\n}\n\nconst parsePeriod = period => {\n  const [, year, month, day] =\n  /^(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?$/g.exec(period) || []\n\n  return (\n    parseUnit('year', year) + parseUnit('month', month) + parseUnit('day', day)\n  )\n}\n\nconst parsePeriodToObject = period => {\n  const [, years, months, days] =\n  /^(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)D)?$/g.exec(period) || []\n\n  return {\n    [YEAR_UNIT]: getNumber(years),\n    [MONTH_UNIT]: getNumber(months),\n    [DAY_UNIT]: getNumber(days)\n  }\n}\n\nconst parseTime = time => {\n  const [, hour, minute, second] =\n  /^(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?$/g.exec(time) || []\n\n  return (\n    parseUnit('hour', hour) +\n    parseUnit('minute', minute) +\n    parseUnit('second', second)\n  )\n}\n\nconst parseTimeToObject = time => {\n  const [, hours, minutes, seconds] =\n  /^(?:(\\d+)H)?(?:(\\d+)M)?(?:(\\d+(?:\\.\\d+)?)S)?$/g.exec(time) || []\n\n  return {\n    [HOUR_UNIT]: getNumber(hours),\n    [MINUTE_UNIT]: getNumber(minutes),\n    [SECOND_UNIT]: getNumber(seconds)\n  }\n}\n\nconst parse = str => {\n  const neg = isNegative(str)\n  const duration = neg ? stripFirstChar(str) : str\n  const splitDuration = duration.split('T')\n  const period = stripFirstChar(splitDuration[0])\n  const time = splitDuration[1]\n\n  let output = 0\n  if (isNonEmptyString(period)) output += parsePeriod(period)\n  if (isNonEmptyString(time)) output += parseTime(time)\n  return neg ? -output : output\n}\n\nexport const convertToObject = str => {\n  const neg = isNegative(str)\n  const duration = neg ? stripFirstChar(str) : str\n  const splitDuration = duration.split('T')\n  const period = stripFirstChar(splitDuration[0])\n  const time = splitDuration[1]\n\n  let output = { [IS_NEGATIVE_UNIT]: neg }\n  output = isNonEmptyString(period)\n    ? Object.assign(output, parsePeriodToObject(period))\n    : Object.assign(output, emptyPeriod)\n  output = isNonEmptyString(time)\n    ? Object.assign(output, parseTimeToObject(time))\n    : Object.assign(output, emptyTime)\n  return output\n}\n\nconst out = (input, toObject = false) => {\n  // Throw error for non-string input\n  if (typeof input !== 'string') {\n    throw new TypeError('expected input to be a string')\n  }\n  // Return null for invalid input\n  if (!isValidXsdDuration(input)) return null\n  // Parse valid input\n  return toObject ? convertToObject(input) : parse(input)\n}\n\nexport default (input, toObject) => out(input, toObject)\n"]}